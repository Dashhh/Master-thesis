 %
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[en]{pracamgr}

% Dane magistranta:
\autor{Adam Starak}{361021}

% TODO[Dodaj tytuł]
\title{Title in English}
\titlepl{Tytuł po polsku}

%\tytulang{An implementation of a difference blabalizer based on the theory of $\sigma$ -- $\rho$ phetors}

%kierunek: 
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{Computer Science}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dr Michał Pilipczuk\\
  Instytut Informatyki\\
  }

% miesiąc i~rok:
\date{\monthyeardate\today}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
%TODO - dodać klasyfikację
\klasyfikacja{D. Software\\
  D.127. Blabalgorithms\\
  D.127.6. Numerical blabalysis}

%TODO - dodać słowa kluczowe]
% Słowa kluczowe:
\keywords{parameterized algorithm}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:

\usepackage{chngcntr}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[]{algorithm2e}
\usepackage{enumitem}
\usepackage{datetime}
\usepackage{amssymb}

\newdateformat{monthyeardate}{%
	\monthname[\THEMONTH], \THEYEAR}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

\newcommand{\wcs}{Weighted Circuit Satisfiability}

\newenvironment{sproof}{%
	\renewcommand{\proofname}{Proof (sketch).}\proof}{\endproof}

\newcommand{\ssf}{spanning star forest}
\newcommand{\ssfp}{{\sc Spanning Star Forest}}
\newcommand{\dssfp}{{\sc Decision Spanning Star Forest}}
\newcommand{\mssfp}{{\sc Maximal Spanning Star Forest}}
\newcommand{\ssfep}{{\sc Spanning Star Forest Extension}}
\newcommand{\domset}{dominating set}
\newcommand{\domsetp}{{\sc Dominating Set} problem}
\newcommand{\cnfsat}{{\sc CNF-SAT}}

\newcommand{\kssf}{\emph{Spanning Star Forest Problem} parameterized by the number of stars}
\newcommand{\ssfe}{\emph{Spanning Star Forest Extension Problem}}
\newcommand{\tsat}{\emph{3-SAT}}

\counterwithin{theorem}{chapter}
\counterwithin{definition}{chapter}
\counterwithin{lemma}{chapter}
\counterwithin{corollary}{chapter}
\counterwithin{claim}{chapter}
\counterwithin{proposition}{chapter}

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
%TODO - dodaj abstract
\begin{abstract}
  W~pracy przedstawiono prototypową implementację blabalizatora
  różnicowego bazującą na teorii fetorów $\sigma$-$\rho$ profesora
  Fifaka.  Wykorzystanie teorii Fifaka daje wreszcie możliwość
  efektywnego wykonania blabalizy numerycznej.  Fakt ten stanowi
  przełom technologiczny, którego konsekwencje trudno z~góry
  przewidzieć.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Blabalizator różnicowy jest podstawowym narzędziem blabalii
fetorycznej.  Dlatego naukowcy z~całego świata prześcigają się
w~próbach efektywnej implementacji.  Opracowana przez prof. Fifaka
teoria fetorów $\sigma$-$\rho$ otwiera w~tej dziedzinie nowe
możliwości.  Wykorzystujemy je w~niniejszej pracy.

\chapter{Preliminaries}\label{r:pojecia}

\section{Structures}

A simple graph $G$ is a pair $(V,E)$ where $V$ denotes a set of vertices and $E$ denotes a set of undirected edges. Let $deg_G(v)$ denote a degree of vertex $v$ in graph $G$ which is the number of adjacent vertices. Let $G \setminus v$ be the abbreviation for $G'=(V(G) \setminus \{v\}, E(G) \setminus \{(u,v): u \in V(G)\})$. For a set $X \subseteq V(G)$ we define by $G[X]$ the graph induced by vertices from $X$. A graph $P_k$ is a path of length $k$. A graph $C_k$ is a cycle of length $k$. A \emph{tree} $T$ is a connected graph which has exactly $|V(T)|-1$ edges. A \emph{spanning tree} $T$ of a graph $G$ is a tree which includes all of the vertices of $G$, with the minimum possible number of edges. A \emph{star} $S$ is a tree of size at least $2$ for which at most one vertex has a degree greater than $1$. A vertex in a \emph{star} that has the greatest degree is called a \emph{center} while the others are called \emph{rays}. A \emph{star} of size 2 has two \emph{candidates} to become a \emph{center}.

\section{Parameterized complexity}

\begin{definition}\label{Parameterized problem}
	A {\textup{parameterized problem}} is a language $L \subseteq \ \Sigma^* \times \mathbf{N}$, where $\Sigma$ is a fixed, finite alphabet. For an instance $(x,k) \in L$, $k$ is called the parameter.
\end{definition}

\begin{definition}\label{FPT algorithm}
	For a parameterized problem $Q$, an \textup{FPT algorithm} is an algorithm $\mathcal{A}$ which, for any input $(x,k)$, decides whether $(x,k) \in Q$ in time $f(k)\cdot n^c$ where c is a constant, independent of $n,k$, and $f$ is a computable function.
\end{definition}

\begin{definition}\label{Kernel}
	A \textup{kernel} for a parameterized problem $Q$ is an algorithm $\mathcal{A}$ that, given an instance $(x,k) \in Q$, works in polynomial time and returns an equivalent instance $(x',k') \in Q$
	such that $|x'| + k' \leq g(k)$ for a computable function $g$, called the \textup{size} of the kernel.
\end{definition}

\begin{definition}
	{\normalfont Parameterized reduction.}
\end{definition}

\section{The W-hierarchy}

As opposed to NP-complete problems, which are equivalent with respect to polynomial-time reductions, it is not clear whether or not the rule applies for hard parameterized problem. As an example, it is proven that there exists a parameterized reduction from Independent Set to Dominating Set. However, nobody has proven that the problems are interreducible. The W-hierarchy, proposed by Downey and Fellows, is an attempt to classify hard parameterized problems. 

\begin{definition}
	A {\textup Boolean circuit} is a directed acyclic graph where the nodes are labeled in the following way:
	\begin{itemize}
		\item every node of indegree $0$ is an input node.
		\item every node of indegree $1$ is an negation node.
		\item every node of indegree $\geq 2$ is either an and-node or or-node.
	\end{itemize}
	
	Additionally, exactly one of the nodes with outdegree 0 is labeled as the {\textup output node}. The {\textup depth} of the circuit is the maximum length of a path from an input node to the output node.
\end{definition}

Assigning 0-1 values to the input nodes determines the value of every node in the obvious way. In particular, if the value of the output gate is 1 in an assignment to the input nodes, then we say that the assignment satisfies the circuit.
\\\\
In {\sc{\wcs}} problem, we are given a circuit $C$ and an integer $k$, the task is to decide if $C$ has a satisfying assignment of weight exactly $k$.

\section{Tree decomposition}

Formally, a tree decomposition of a graph $G$ is a pair $\mathcal{T} = (T, \{X_t\}_{t\in V(T)})$ where $\mathcal{T}$ is a tree whose every node $t$ is assigned a vertex subset $X_t \subseteq V(G)$, called a bag, such that the following three conditions hold:
\begin{itemize}
	\item[(T1)] $\bigcup_{t\in V(T)}X_t = V(G)$.
	\item[(T2)] For every $(v,u) \in E(G)$ there exists a bag $t$ of $\mathcal{T}$ such that $v,u \in X_t$.
	\item[(T3)] For every $v \in V(G)$ the set $T_v = \{t \in V(T): v \in X_t\}$ induces a connected subtree of T.
\end{itemize}

The width of a tree decomposition $\mathcal{T} = (T,\{X_t\}_{t\in V(T)})$, denoted as $w(\mathcal{T})$, is equal to $\max_{t \in V(T)} |X_t| - 1$. The treewidth of a graph $G$, denoted as $tw(G)$, is the minimal width over all tree decompositions of $G$.
\\\\
A nice tree decomposition of a graph $G$ is a tree decomposition $(T, \{X_t\}_{t \in V(T)})$ such that
\begin{itemize}
	\item $X_i = \emptyset$ if $i$ is either root or leaf.
	\item Every non-leaf node is of one of the three following types:
	\begin{itemize}
		\item \textbf{Introduce node}: a node $t$ with exactly one child $t'$ such that $X_t = X_{t'} \cup \{v\}$ for some vertex $v \notin X_{t'}$.
		\item \textbf{Forget node}: a node $t$ with exactly one child $t'$ such that $X_t = X_{t'} \setminus \{w\}$ for some vertex $w \in X_{t'}$
		\item \textbf{Join node}: a node $t$ with exactly two children $t_1$, $t_2$ such that $X_t = X_{t_1} = X_{t_2}$.
	\end{itemize}
\end{itemize}

\subsection{Path decomposition}

A path decomposition $\mathcal{P}=(P,\{X_p\}_{p \in V(P)})$ of a graph $G$ is a specific case of a tree decomposition. Namely, $P$ forms a path. In addition, the pathwidth of a graph $G$, denoted as $pw(G)$, is the minimal width over all path decompositions of $G$. A nice path decomposition of a graph $G$ is a path decomposition $(P,\{X_p\}_{p \in V(P)})$ such that there exists a root, one leaf and all the inner nodes are either an introduce node or forget node.

\chapter{Spanning Star Forest}\label{r:losers}

In this chapter we show three different variants of the \ssfp{}. We start with its decision version. Then, we propose an algorithm working in linear time that finds an arbitrary \ssf{}. In the last section, we constrain the number of stars that a solution can have. The problem formulated in such a way turns out to be NP-complete.

\section{Decision Spanning Star Forest problem}

For a given graph $G$, we say that $S$ is a \ssf{} if $S$ is a subgraph of $G$ that contains all vertices of $G$ and every connected component of $S$ is a star. In decision version \ssfp{} given a graph $G$, the objective is to determine whether there exists a \ssf{}.

It turns out that the problem formulated in such a way is relatively simple. Although, various variants described in this paper make it more complex. The following lemma easily clarifies all the concerns about its hardness.

\begin{lemma}\label{SSF lemma}
 A graph $G$ has a \ssf{} if and only if it does not contain any isolated vertices.
\end{lemma}

\begin{proof}
	If $G$ has a \ssf{} $S$, then trivially for all $v \in V(G)\ 1 \leq deg_S(v) \leq deg_G(v)$. Thus, none of the vertices is isolated.
	
	For the opposite direction, we prove the lemma by induction on $|V(G)|$. Assume $|V(G)|=2$. The statement trivially holds because a graph consisting of one edge and two vertices is a correct \ssf{}. Let $|V(G)| >2$. Suppose that for every vertex $v$, graph $G \setminus v$ has an isolated vertex. Then, it holds that for all $v \in V(G)\ deg_G(v)=1$. Thus, $G$ consists of a set of disjoint edges which is a correct \ssf{}. Now, suppose contrary, that there exists a vertex $v$ such that $G \setminus v$ has no isolated vertices. From the inductive assumption, let $S$ be a \ssf{} of a graph $G \setminus v$, $u$ be a vertex such that $(u,v) \in E(G)$ and $w \in N_S[u]$. Consider the two following cases:
	\begin{enumerate}
		\item Suppose $u$ is a ray. It implies that $w$ is a center and $deg_S(w) \geq 2$. Then, $S'=\big(V(S) \cup \{v\},(E(S) \cup \{(u,v)\}) \setminus \{(u,w)\}\big)$ is a correct solution for graph $G$.
		\item Otherwise, $u$ is either a candidate or a center. Then, $S'=\big(V(S) \cup \{v\}, E(S) \cup \{(u,v)\}\big)$ is a correct solution for graph $G$.
	\end{enumerate}
	
\end{proof}
	Application of Lemma \ref{SSF lemma} yields the following result for \dssfp{}.

\begin{theorem}
	\dssfp{} can be solved in linear time.
\end{theorem}

\begin{proof}
	Given a graph $G = (V,E)$ the answer is YES if for all $v \in V(G)\ deg_G(v) \neq 0$ and NO otherwise.
\end{proof}

\section{Spanning Star Forest Problem}

In this section we focus on obtaining an arbitrary solution for a given instance of \ssfp{}. Firstly, let us introduce two claims which help to normalize an instance and make the algorithm more clear to the reader.

\begin{claim} \label{SSF sum}
	Family of disjoint \ssf{} is a \ssf{}.
\end{claim}

\begin{claim} \label{Spanning tree SSF}
	$G$ has a \ssf{} if and only if its spanning tree $T$ has.
\end{claim}

The first claim can be trivially proven by the definition of a \ssf{} while the second one follows directly from Lemma \ref{SSF lemma}. Equipped with this information, all that is left to do, is to design an algorithm which solves the problem for trees.

\begin{algorithm}\label{alg1}
	\KwData{Connected graph $G$}
	\KwResult{\ssf{} of $G$}
	$T \leftarrow$ $SpanningTree(G)$\;
	$S \leftarrow$ $\emptyset$\;
	\For{$v$: $postorder(T)$ and $v$ is not a root}{
		\If{$v \notin V(S)$}{
			$S \leftarrow S \cup \{(u,v)\}$ where $u = parent(v)$\;
		}
	}
	$v \leftarrow root(T)$\;
	\If{$v \notin V(S)$}{
		$S \leftarrow S \cup \{(u,v)\}$ where $u$ is a child of $v$\;
	}
	\Return $S$\;
	\caption{Obtaining a spanning star forest from a connected graph.}
\end{algorithm}

Firstly, the algorithm creates a spanning tree $T$. Then, it does a simple bottom-up traversal. If the current node $v$ has not been added to the solution yet, the algorithm adds it together with its parent. If the root has not been added to the solution during the for loop, we add an arbitrary edge to the solution which finishes the algorithm. If the input graph is not connected, we run the algorithm separately on each component and then merge results based on claim \ref{SSF sum}.

There is one non-trivial operation that the algorithm does. Specifically, if the root has not  been added during the for loop, we connect the root to any existing star without checking whether it remains a correct star.

\begin{proposition}\label{ssf root}
	If $(u_1,u_2),(u_2,u_3) \in E(S)$, $u_2 = parent(u_1)$ and $u_3=parent(u_2)$, then $u_3$ is the root.
\end{proposition}

\begin{proof}
	Suppose contrary, that $u_3$ is not the root. Then, both $(u_1,u_2)$ and $(u_2,u_3)$ have been added during the for loop. Contradiction because $u_2$ has been added to the solution during $u_1$'s iteration and the algorithm should not have added the edge $(u_2,u_3)$. Thus, $u_3$ is the root.
\end{proof}

From the Proposition \ref{ssf root} we infer that no two consecutive parents are added to the solution unless the last node is the root. It means that every root's child is either a center or a candidate. Thus, adding an arbitrary root's edge is a correct step in the algorithm. Moreover, there are no paths of length greater than $2$. If there was one, it would mean that the root is connected to two different vertices which is false.

\begin{lemma}\label{alg1 correctness}
	Algorithm \ref{alg1} is correct.
\end{lemma}

\begin{proof}
	Clearly, $S$ is a forest. So, it suffices to check that there are no isolated vertices and the solution does not induce a path of length $3$. The first claim is true because we enumerate over all vertices and pair them up with its parent if a vertex has not been added to the solution in previous iteration. So is the second claim based on the information inferred from Proposition \ref{ssf root}.
\end{proof}

Having proven the correctness of Algorithm \ref{alg1} we proceed to the complexity analysis.

\begin{theorem}
	A solution for \ssfp{} can be found in linear time.
\end{theorem}

\begin{proof}
	An arbitrary spanning tree of any graph can be found in linear time. The main loop has $n-1$ iterations (every vertex is processed once), each of which takes constant time.
	Thus, the total runtime is linear.
\end{proof}

The problem stated without any constraints is simple. Both decision and normal version of the problem can be solved in linear time. The next variations investigated in this paper yield more complex results.

\section{Maximal Spanning Star Forest problem}

In \mssfp{}, given a graph $G$ and a natural number $k$, the objective is to determine whether there exists a \ssf{} $S$ such that the number of connected components is at most $k$.

It is natural to ask whether one can find a solution that minimizes the number of connected components. The problem formulated in that way looks slightly different than the previous one. From the other hand, the problem resembles \domsetp{}, which is defined as follows:

\begin{definition}
	\domsetp: Given a graph $G$ and a positive integer $k$ find a set $D$ such that $|D| \leq k$ and every vertex from the graph is adjacent to one of the vertices from $D$.
\end{definition}

At first glance, one can say that a center is related to a dominating vertex whereas a ray is related to a dominated vertex. Candidates might be represented by either a dominating or dominated vertex. However, we cannot finish our research at this point because in \domsetp{} isolated dominating vertices are allowed and some vertices are dominated by multiple neighbors. 

To give a systematic parameterized reduction between these two problems, we need to get a better understanding of \domsetp{}.

\begin{definition}
	Given an instance $(G,k)$ of Dominating Set Problem that does not contain any isolated vertices and a solution $D$, a {\normalfont domination mapping} is a function $m:V(G) \setminus D \rightarrow D$ such that satisfies $(x,m(x)) \in E(G)$ for all $x \in Dom(m)$.
\end{definition}

\begin{lemma}\label{dom mapping}
	Let $G$ be a graph without isolated vertices and let $D$ be a dominating set of minimal size. Then, there exists a domination mapping $m$ such that $m$ is surjective.
\end{lemma}

\begin{proof}
	Let $m$ be a dominating mapping that maximizes $|im(m)|$. If $m$ is surjective, then the proof is finished. Otherwise, there exists a vertex $v$ such that $v \notin im(m)$. Consider the following cases::
	\begin{enumerate}
		\item Suppose $N_G(v) = \emptyset$. Contradiction, $G$ has no isolated vertices.
		\item Suppose $u \in N_G(v) \cap D$. Contradiction, $D$ was said to be a solution of minimal size whereas $D \setminus \{u\}$ is a valid, smaller solution.
		\item Suppose $u \in N_{G}(v) \setminus D$ and $w = m(u)$. If $|m^{-1}(w)|=1$, then $((D \setminus \{v,w\}) \cup u)$ is a valid, smaller solution for a graph $G$. Contradiction.
		\item Suppose $u \in N_{G}(v) \setminus D$ and $w = m(u)$. If $|m^{-1}(w)| > 1$ then a mapping:
		\begin{equation*}
			m'(x) = \begin{cases}
			v, & \text{if }x = u \\
			m(x), &\text{otherwise} \\
			\end{cases}
		\end{equation*}
		is a valid mapping that satisfies $im(m) \subsetneq im(m')$. Thus, one can create a new mapping $m''$ inductively such that $m''$ is surjective. Contradiction, we assumed that no such mapping exists. 
	\end{enumerate}
	
	Since all the first three cases led to a contradiction and the last one shows how to inductively expand the image of a domination mapping, we may conclude that there exists a domination mapping $m$ such that $m$ is surjective.  
\end{proof}

Armed with the lemma, we are ready to prove the main theorem of the section.

\begin{theorem}\label{dom ssf}
	\mssfp{} is NP-Complete.
\end{theorem}

\begin{proof}
	Membership in NP: The witness is a spanning star forest $S$. The verifier checks if all the vertices from input graph are included in $S$, there are no isolated vertices and $S$ does not induce a $P_3$ nor $C_{> 2}$.
	\\\\
	Hardness: We show hardness by a reduction from \domsetp{} that completes the proof. Given graph $G$ and integer $k$, in PTIME, for every isolated vertex $v \in V(G)$ introduce a vertex $v'$ and an edge $(v,v')$. Now, we claim that $(G,k)$ is a YES-instance of \domsetp{} if and only if $(G',k)$ is a YES-instance of \mssfp{}. 
	
	The backward implication is simple. Suppose $S$ is a solution for $(G',k)$. We create the \domset{} $D$ as follows: for every star of size $2$ pick an arbitrary candidate that is present in graph $G$ and for every star of size greater than $2$ pick a center. Obviously $|D| \leq k$ because there are at most $k$ connected components in $S$. Every vertex from $G'$ is adjacent to one of the centers or candidates that we chose during construction of a set $D$.
	
	To prove the forward implication, let $D$ be a solution of minimal size for $(G,k)$. Obviously, $D$ is also a minimal dominating set for the graph $G'$ as $D$ contains every isolated vertex. Thus, by Lemma \ref{dom mapping}. there exists a mapping $m$ that is surjective. Now, we claim that the graph $S=(V(G'),\{(x,m(x)): x \in Dom(m)\})$ is a correct solution for the instance $(G',k)$ of \mssfp{}. By surjectivity, there are no isolated vertices in $S$. Moreover, there is no path nor cycle of length $3$ because $m$ maps vertices from $V(G') \setminus D$ to $D$ and for all $v \in V(G') \setminus D$, $deg_S(v)=1$.
	
\end{proof}

The problems look so similar that one could ask whether the reverse reduction is true. Indeed, with a small twist in the previous idea, one can prove the reverse reduction instantly. In the proof we only point out the construction because the concept of proving the instance equivalence remains the same.

\begin{theorem}\label{ssf dom}
	There exists a parameterized reduction from \mssfp{} to \domsetp{} parameterized by the size of dominating set.
\end{theorem}

\begin{sproof}
	Let $(G,k)$ be an instance of \mssfp{}. We create the instance $(G',k')$ for \domset{} as follows: let $G'=G$. If $G$ contains an isolated vertex, then $k'=0$. Otherwise, the value remains the same. Now, we claim that $(G,k)$ is a YES-instance for \mssfp{} if and only if $(G',k')$ is a YES-instance for \domset.
	
	To prove the following reduction one can use the method which was described in Theorem \ref{ssf dom} with a little remark: if an instance $(G,k)$ contains an isolated vertex, then obviously it is a NO-instance for \mssfp{} and so is $(G',k')$ for \domset{} because $G'$ is not an empty graph.
\end{sproof}

The theorem implies that \mssfp{} is as hard as \domsetp{} and the problems are \emph{interreducible}. Thus, we can immediately obtain the following corollary.

\begin{corollary}
	\mssfp{} is {\normalfont W[2]-complete}.
\end{corollary}

\chapter{Spanning Star Forest Extension}

In this chapter, we significantly change the problem. Let $G$ be a graph and $F \subseteq E(G)$ be a set of \emph{forced edges}. In the \ssfep{} the question, that we want to answer now, is whether there exists a \ssf{} $S$ such that $F \subseteq E(S)$. We used three different parameters: number of forced edges, number of free edges and treewidth. 

\section{Preliminaries}

\subsection{Notation}

In further, we denote by $F$ a set of \emph{forced edges}. Vertices that have exactly one forced edge are called \emph{forced candidates}. Similarly, if a subset of $F$ forms a \emph{forced star} of size greater than $3$ we call its particles a \emph{forced center} and \emph{forced rays} consequently. We denote by $F_R$ a set of all forced rays and by $F_C$ a set of all forced centers. Vertices that does not belong to $V(F)$ are called \emph{free vertices}.

\subsection{Instance normalization} 

Notice that this time we do not have any limit on the number of connected components. The hardness of the problem lays in choosing which of the forced candidates should become a forced center and which one should become a forced ray. Also, observe that a star is a primitive structure. The star's maximal radius is equal to $2$. It means that we can look at the problem rather locally than globally. Thus, it is possible to normalize instances i.e. try to remove vertices that are "far enough" from forced vertices.

Let $(G, F)$ be an arbitrary instance of \ssfep{}. Firstly, consider trivial cases.

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},labelindent=0pt]
	\item If graph $G$ contains an isolated vertex, then it is a NO-instance.
	\item If $F$ induces in $G$ a path or a cycle of size at least $3$, then it is a NO-instance.
\end{enumerate}

For the sake of simplicity, if a vertex has one neighbor only, we can add the edge to the set of forced edges. There is no other way to create a spanning star forest without taking that particular edge.

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume]
	\item If a free vertex $u$ satisfies $N[u] = \{v\}$, then add $(u,v)$ to $F$.
\end{enumerate}

Suppose that a subset of forced edges forms a star of size at least $3$. Then, the forced center is already determined. Thus, we can remove from the instance all the edges that has exactly one end in forced ray and the other in a free vertex. 

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume,wide, labelwidth=!, labelindent=0pt]
	\item Suppose $F_R$ is a set of forced rays. Remove the set of edges $\{(u,v): u \in F_R,\ v \in V(G) \setminus V(F)\}$
\end{enumerate}

Moreover, notice that after exhaustive application of previous reductions, for all $v \in F_R$, it is true that $deg(v)=1$. That is, forced rays are only connected to its forced centers. So, for every forced star, contracting the set of forced rays into a forced candidate, does not have an impact on the solution.

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume,wide, labelwidth=!, labelindent=0pt]
	\item Suppose that $(G,F)$ is the output graph after exhaustive application of previous reductions. For every forced star, contract the set of forced rays into a forced candidate.
\end{enumerate}

Let us summarize our work and infer how an input graph looks like. Currently, no two forced edges have a common vertex. So, we immediately obtain the following:

\begin{corollary}
	After exhaustive application of Reduction 5, $F$ is a matching.
\end{corollary}

We can distinguish three types of different forced edges. Ones that have outgoing edges from both ends, one end and ones that have no outgoing edges. For the sake of clarity, we can remove isolated forced edges.

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume,wide, labelwidth=!, labelindent=0pt]
	\item Remove isolated forced edges.
\end{enumerate}

Now, let us focus on the second part of a graph i.e. free vertices. As we have seen in previous chapter, by Lemma \ref{SSF lemma}, there exists a spanning star forest if and only if there are no isolated vertices. Let $V_P = \{u: (u,v) \in (E(G) \setminus F) \text{ and } u,v \notin V(F)\}$ and $V_{NP} = V(G) \setminus V_P$. Finally, $G_{NP} = G[V_{NP}]$ and $G_P = G[V_P]$. Notice the immediate consequence of the partitioning of the graph $G$.

\begin{claim}\label{gp cut}
	$G_P$ always has a solution.
\end{claim}

To prove the claim, we can simply apply lemma \ref{SSF lemma}. $G_P$ does not have any forced edges nor isolated vertices. All that is left to do is to prove that edges between $G_P$ and $G_{NP}$, that were lost during partitioning, does not have any impact on the solution. The following theorem proves the intuition.

\begin{theorem}\label{GNP partition}
	An instance $(G,F)$ has a solution if and only if $(G_{NP},F)$ has one.
\end{theorem}

\begin{proof}
	The backward implication is trivial. Suppose $S$ is a solution for $(G_{NP},F)$. We can partition $G$ into $G_P$ and $G_{NP}$ and find a solution, say $S'$, for a graph $G_P$. Then, $S \cup S'$ is a correct solution for $G$.
	
	Now, consider the forward implication. Let $S$ be a solution for $(G, F)$. Assume contrary that there exists a vertex $u \in V(G_{NP})$ that does not belong to any star. Trivially, vertices from $V(F)$ are covered. Thus, $u \in V(G_{NP}) \setminus V(F)$. If $u \in V(G_{NP}) \setminus V(F)$ it follows that for all $(u,v) \in E(G)$, $(u,v) \in E(G_{NP})$. If it was not true, the vertex $u$ would have been placed in the graph $G_P$ during partitioning. Thus, there exists an edge $(u,v) \in E(S)$ such that $(u,v) \in E(G_{NP})$. Contradiction because $u$ belongs to a star.
	
\end{proof}

Theorem \ref{GNP partition} provides us the next rule:

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume]
	\item Update $G = G_{NP}$.
\end{enumerate}

Now, we want to present the last set of reduction rules that we can infer after the application of previous ones:

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume]
	\item If $u \notin V(F)$, $(u,v),(u,w) \in E(G)$ and $(v,w) \in F$, then remove $u$.
	\item If $(u,v) \in F$ and $deg(u)=1$, then apply $G = G \setminus N[v]$.
\end{enumerate}

To sum up, after exhaustive application of reduction rules, we will either conclude that it is a NO-instance or output a very structured graph. There exists a matching $F$ consisting of all the forced candidates. Additionally, all the free vertices are connected to at least two different ends of forced edges.

\section{NP-completeness}

Let $(G,F)$ be an instance of \ssfep{} after normalization. Then, $G$ consists of vertices of two types: ones that have only edges to vertices from $V(F)$ and ones that have exactly one forced edge (and potentially many free ones). Such a representation substantially simplifies further investigations. Indeed, we can prove that the problem is NP-complete.

\begin{theorem}
	\ssfep{} is NP-complete.
\end{theorem}

\begin{proof}
	Membership in NP: The witness is a spanning star forest $S$. The verifier checks if every connected component is a star and if every forced edge is included in the solution.
	\\\\
	Hardness: we show a reduction from \cnfsat{}. Let $\phi$ be an arbitrary instance. We create a graph $G$ as follows: for every variable $x_i$ we introduce vertices $x_i,\neg x_i$ and a forced edge $(x_i,\neg x_i)$. For every clause $c_i$ we introduce a vertex $c_i$. For every $x_k$ (symmetrically $\neg x_k$) we introduce an edge $(x_k,c_p)$ if and only if $x_k$ is present in p'th clause. Now, we claim that $\phi$ is satisfiable if and only if $(G, F)$ has a \ssf{}.
	
	Backward implication: Let $S$ be a solution for $(G,F)$. Then, a set of centers is a correct evaluation that satisfies the formula $\phi$ because every clause $S$ has a witness.
	
	To prove the forward implication, assume there exists an evaluation $\sigma$ of variables that satisfies the formula. Let $C = \{l_i: \sigma(l_i) = 1\} $. Note that $C$ contains either $x_i$ or $\neg x_i$. Now, let us construct a solution $S$. Firstly, include all the isolated edges. Then, for every vertex representing a clause $c_i$ take an arbitrary $l_j$ such that $l_j \in N(c_i) \cap C$ and include edge $(c_i, l_j)$ into the solution. The operation is safe. All sets $ N(c_i) \cap C$ are nonempty because there exists a witness $l_k$ that satisfies the clause and there exists an edge between a literal and a clause.
\end{proof}

Surprisingly, \tsat{} is trivially encoded in \ssfe{}.

\lemma{Any CNF formula can be represented as a formula where each clause has size at most 3} \label{cnf to 3sat}
\begin{lemma}
	There exists a reduction from \ssfe{} to \tsat.
\end{lemma}

\begin{proof}
	Let $(G,F)$ be an arbitrary normalized instance of \ssfe{}. We create a formula $\phi$ as follows: for every isolated edge $(u,v)$ we introduce literals $x$ and $\neg x$. For every vertex $v \in V(G)\setminus V(F)$ we introduce a clause $c_v$. Literal $l$ is present in a clause $c_j$ if and only if there exists an edge between vertices corresponding to $c_i$ and $l$. Application of lemma \ref{cnf to 3sat} to $\phi$ produces a formula $\phi'$ that is a correct instance of \tsat.
	
	Proof of correctness was previously described in the theorem. We omit it for the sake of clarity.
\end{proof}

\section{Parametrization by the number of isolated edges}

\section{Parametrization by the number of non-isolated edges}

\section{Parametrization by treewidth}

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
    function}, Mathematica Absurdica, 117 (1965) 338--9.

\bibitem[Blar16]{eb1} Elizjusz Blarbarucki, \textit{O pewnych
    aspektach pewnych aspektów}, Astrolog Polski, Zeszyt 16, Warszawa
  1916.

\bibitem[Fif00]{ffgg} Filigran Fifak, Gizbert Gryzogrzechotalski,
  \textit{O blabalii fetorycznej}, Materiały Konferencji Euroblabal
  2000.

\bibitem[Fif01]{ff-sr} Filigran Fifak, \textit{O fetorach
    $\sigma$-$\rho$}, Acta Fetorica, 2001.

\bibitem[Głomb04]{grglo} Gryzybór Głombaski, \textit{Parazytonikacja
    blabiczna fetorów --- nowa teoria wszystkiego}, Warszawa 1904.

\bibitem[Hopp96]{hopp} Claude Hopper, \textit{On some $\Pi$-hedral
    surfaces in quasi-quasi space}, Omnius University Press, 1996.

\bibitem[Leuk00]{leuk} Lechoslav Leukocyt, \textit{Oval mappings ab ovo},
  Materiały Białostockiej Konferencji Hodowców Drobiu, 2000.

\bibitem[Rozk93]{JR} Josip A.~Rozkosza, \textit{O pewnych własnościach
    pewnych funkcji}, Północnopomorski Dziennik Matematyczny 63491
  (1993).

\bibitem[Spy59]{spyrpt} Mrowclaw Spyrpt, \textit{A matrix is a matrix
    is a matrix}, Mat. Zburp., 91 (1959) 28--35.

\bibitem[Sri64]{srinis} Rajagopalachari Sriniswamiramanathan,
  \textit{Some expansions on the Flausgloten Theorem on locally
    congested lutches}, J. Math.  Soc., North Bombay, 13 (1964) 72--6.

\bibitem[Whi25]{russell} Alfred N. Whitehead, Bertrand Russell,
  \textit{Principia Mathematica}, Cambridge University Press, 1925.

\bibitem[Zen69]{heu} Zenon Zenon, \textit{Użyteczne heurystyki
    w~blabalizie}, Młody Technik, nr~11, 1969.

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
