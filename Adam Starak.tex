 %
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[en]{pracamgr}

% Dane magistranta:
\autor{Adam Starak}{361021}

% TODO[Dodaj tytuł]
\title{Title in English}
\titlepl{Tytuł po polsku}

%\tytulang{An implementation of a difference blabalizer based on the theory of $\sigma$ -- $\rho$ phetors}

%kierunek: 
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{Computer Science}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dr Michał Pilipczuk\\
  Institute of Informatics\\
  }

% miesiąc i~rok:
\date{\monthyeardate\today}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
%TODO - dodać klasyfikację
\klasyfikacja{D. Software\\
  D.127. Blabalgorithms\\
  D.127.6. Numerical blabalysis}

%TODO - dodać słowa kluczowe]
% Słowa kluczowe:
\keywords{parameterized algorithm}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:

\usepackage{chngcntr}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[]{algorithm2e}
\usepackage{enumitem}
\usepackage{datetime}
\usepackage{amssymb}

\newdateformat{monthyeardate}{%
	\monthname[\THEMONTH], \THEYEAR}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

\newcommand{\wcs}{Weighted Circuit Satisfiability}

\newenvironment{sproof}{%
	\renewcommand{\proofname}{Proof (sketch).}\proof}{\endproof}

\newcommand{\ssf}{spanning star forest}
\newcommand{\ssfp}{{\sc Spanning Star Forest}}
\newcommand{\dssfp}{{\sc Decision Spanning Star Forest}}
\newcommand{\mssfp}{{\sc Minimal Spanning Star Forest}}
\newcommand{\ssfep}{{\sc Spanning Star Forest Extension}}
\newcommand{\domset}{dominating set}
\newcommand{\domsetp}{{\sc Dominating Set}}
\newcommand{\indset}{{\sc Independent Set}}
\newcommand{\cnfsat}{{\sc CNF-SAT}}

\newcommand{\degree}[2]{\textrm{deg}_{#1}(#2)}
\DeclareMathOperator{\Ima}{Im}

\newcommand{\kssf}{\emph{Spanning Star Forest Problem} parameterized by the number of stars}
\newcommand{\ssfe}{\emph{Spanning Star Forest Extension Problem}}
\newcommand{\tsat}{\emph{3-SAT}}

\counterwithin{theorem}{chapter}
\counterwithin{definition}{chapter}
\counterwithin{lemma}{chapter}
\counterwithin{corollary}{chapter}
\counterwithin{claim}{chapter}
\counterwithin{proposition}{chapter}

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
%TODO - dodaj abstract
\begin{abstract}
  W~pracy przedstawiono prototypową implementację blabalizatora
  różnicowego bazującą na teorii fetorów $\sigma$-$\rho$ profesora
  Fifaka.  Wykorzystanie teorii Fifaka daje wreszcie możliwość
  efektywnego wykonania blabalizy numerycznej.  Fakt ten stanowi
  przełom technologiczny, którego konsekwencje trudno z~góry
  przewidzieć.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\begin{theorem}\label{thm-ssfp}
	\ssfp{} can be solved in linear time. Moreover, given a graph $G$, one can find a solution in linear time if it exists.
\end{theorem}

\begin{theorem}\label{thm-mssfp-w2c}
	\mssfp{} is \textup{W[2]}-complete.
\end{theorem}

\begin{theorem}\label{thm-mssfp-time}
	\mssfp{} can be solved in $\mathcal{O}^*(n^k)$.
\end{theorem}

\begin{theorem}\label{thm-mssfp-lowerbound}
	Suppose that $k \geq 3$ and $\epsilon' > 0$. Unless \domsetp{} with parameter equal to $k$ cannot be solved in time $\mathcal{O}(N^{k-\epsilon'})$, where $N$ is the number of vertices, there does not exist a constant $\epsilon >0$ and an algorithm for \mssfp{} with parameter equal to $k$ that achieves running time  $\mathcal{O}(N^{k-\epsilon})$, where $N$ is the number of vertices.
\end{theorem}

\begin{theorem}\label{thm-ssfep-npc}
	\ssfep{} is \textup{NP}-complete.
\end{theorem}

\begin{theorem}\label{thm-ssfep-nokernel}
	\ssfep{} parameterized by the number of forced edges does not admit a polynomial kernel.
\end{theorem}

\begin{theorem}\label{thm-ssfep-fe-time}
	\ssfep{} parameterized by the number of forced edges can be solved in time $\mathcal{O}^*(2^{|F|})$ where $|F|$is the number of forced edges.
\end{theorem}

\begin{theorem}\label{thm-ssfep-seth}
	Unless SETH fails, there is no algorithm for \ssfep{} parameterized by the number of forced edges that achieves running time $\mathcal{O}^*((2-\epsilon)^{|F|})$ for any $\epsilon > 0$, where $|F|$ is the number of forced edges.
\end{theorem}

\begin{theorem}\label{thm-ssfep-kernel}
	\ssfep{} parameterized by the number of free vertices admits a linear kernel.
\end{theorem}

\begin{theorem}\label{thm-ssfep-free-alg}
	\ssfep{} parameterized by the number of free vertices can be solved in ??.%TODO add time%
\end{theorem}

\begin{theorem}\label{thm-ssfep-tw-time}
	\ssfep{} parameterized by treewidth can be solved in time $2^{tw}$.
\end{theorem}

\begin{theorem}\label{thm-ssfep-tw-seth}
	Unless SETH fails, there is no algorithm for \ssfep{} parameterized by treewidth that achieves running time $\mathcal{O}^*((2-\epsilon)^{tw})$ for any $\epsilon > 0$, where \textup{\textrm{tw}} is treewidth of the input graph.
\end{theorem}

\chapter{Preliminaries}

\section{Structures}

In a simple graph $G$ we denote by $V(G)$ and $E(G)$ a set of vertices and edges respectively. 
Let $\degree{G}{v}$ denote a degree of vertex $v$ in graph $G$ which is the number of adjacent vertices. 
Let $G \setminus v$ be the abbreviation for $G'=(V(G) \setminus \{v\}, E(G) \setminus \{(u,v): u \in V(G)\})$. 
An induced graph $G'$ of $G$ is a subgraph formed from a subset of vertices and all the edges between them that are present in $G$. For a set $X \subseteq V(G)$ we define by $G[X]$ the graph induced by vertices from $X$. 
A graph $P_k$ is a path of length $k$. A graph $C_k$ is a cycle of length $k$. 
A \emph{tree} $T$ is a connected graph which has exactly $|V(T)|-1$ edges. 
A \emph{spanning tree} $T$ of a graph $G$ is a connected subgraph which includes all of the vertices of $G$, with the minimum possible number of edges.
A \emph{star} $S$ is a tree of size at least $2$ for which at most one vertex has a degree greater than $1$. 
A star of size at least $3$ consists of a \emph{center}, that is a vertex of the greatest degree, and \emph{rays} - vertices of degree $1$. 
A \emph{star} of size 2 has two \emph{candidates}.
For a given graph $G$, we say that $S$ is a \ssf{} if $V(S)=V(G)$ and every connected component of $S$ is a star. 

\section{Parameterized complexity}

In computer science, \emph{parameterized complexity} is a young branch of computational complexity theory. The first systematic paper was released in 1990 by Downey and Fellows. The further investigations of researchers led to numerous theorems and hypotheses. To begin with, let us formally define a parameterized problem. For the sake of clarity, all the definitions are taken from the book (parameterized complexity).

%TODO add Downey, Rod G.; Fellows, Michael R. (1999). Parameterized Complexity%

\begin{definition}\label{Parameterized problem}
	A {\textup{parameterized problem}} is a language $L \subseteq \ \Sigma^* \times \mathbf{N}$, where $\Sigma$ is a fixed, finite alphabet. For an instance $(x,k) \in L$, $k$ is called the \textup{parameter}.
\end{definition}

See the example below to understand the concept:

\begin{definition}
	\domsetp{}: Given a graph $G$ and a positive integer $k$ find a set $D$ such that $|D| \leq k$ and every vertex from the graph is either in $D$ or is adjacent to one of the vertices from $D$.
\end{definition}

There might be multiple different parameters for a single problem. For example, in this paper, we will investigate thoroughly a problem with respect to three different parameters. More interestingly, each parametrization yields different results. 

Also, parameterized complexity helped to distinguish hardness of NP-complete problems. The first class is called FPT (fixed parameter tractable). A problem is in FPT if and only if it has an FPT algorithm defined below:

\begin{definition}\label{FPT algorithm}
	For a parameterized problem $Q$, an \textup{FPT algorithm} is an algorithm $\mathcal{A}$ which, for any input $(x,k)$, decides whether $(x,k) \in Q$ in time $f(k)\cdot $ where c is a constant, independent of $n,k$, and $f$ is a computable function.
\end{definition}

Another important class of parameterized problems is called an XP class. Similarly, a problem is in XP if and only if it has an XP algorithm defined below:

\begin{definition}
	For a parameterized problem $Q$, an \textup{XP algorithm} is an algorithm $\mathcal{A}$ which, for any input $(x,k)$, decides whether $(x,k) \in Q$ in time $n^{f(k)}\cdot n^c$ where c is a constant, independent of $n,k$, and $f$ is a computable function.
\end{definition}

\emph{W-hierarchy} is an alternative way of classifying hard problems. Since it is not the main topic of the paper, we just want to mention that W-hierarchy is an ascending chain of classes that follows: $W[1] \subseteq W[2]...$ . 

Having discussed various complexity classes, let us introduce a framework for reducing one parameterized problem to another. The mechanism described below is widely used in the paper.

\begin{definition}
	Let $P,Q \subseteq \Sigma^* \times \mathbb{N}$ be two parameterized languages. A  \textup{parameterized reduction} from $P$ to $Q$ is an algorithm $\mathcal{A}$ that given $(x,k) \in P$ outputs $(x',k') \in Q$ such that the following three conditions hold:
	\begin{enumerate}
		\item $(x,k)$ is a YES-instance of $P$ if and only if $(x',k')$ is a YES-instance of $Q$.
		\item $k' \leq g(k)$ for some computable function $g$.
		\item The running time of $\mathcal{A}$ is $f(k) \cdot |x^{\mathcal{O}(1)}|$ for some computable function $f$.
	\end{enumerate}
\end{definition}

As an example, \indset{} is a W[1]-complete problem whereas \domsetp{} is a W[2]-complete problem. It is not known what is the correlation between FPT and W[1] classes. In this paper, we assume that W[1] $\neq$ FPT. 



Last but not least, we introduce a \emph{kernelization algorithm} - a way of reducing input instances:

\begin{definition}\label{Kernel}
	A \textup{kernel} for a parameterized problem $Q$ is an algorithm $\mathcal{A}$ that, given an instance $(x,k) \in Q$, works in polynomial time and returns an equivalent instance $(x',k') \in Q$
	such that $|x'| + k' \leq g(k)$ for a computable function $g$, called the \textup{size} of the kernel.
\end{definition}

Kernelization was not a highly explored area. Not until the year 2008, when researchers developed a technique to prove lower bounds on kernels. We discuss the framework as well as show an example further in this paper.

\section{Tree decomposition}

Formally, a tree decomposition of a graph $G$ is a pair $\mathcal{T} = (T, \{X_t\}_{t\in V(T)})$ where $\mathcal{T}$ is a tree whose every node $t$ is assigned a vertex subset $X_t \subseteq V(G)$, called a \emph{bag}, such that the following three conditions hold:
\begin{itemize}
	\item[(T1)] $\bigcup_{t\in V(T)}X_t = V(G)$.
	\item[(T2)] For every $(v,u) \in E(G)$ there exists a bag $t$ of $\mathcal{T}$ such that $v,u \in X_t$.
	\item[(T3)] For every $v \in V(G)$ the set $T_v = \{t \in V(T): v \in X_t\}$ induces a connected subtree of T.
\end{itemize}

The width of a tree decomposition $\mathcal{T} = (T,\{X_t\}_{t\in V(T)})$, denoted as $\textrm{tw}(\mathcal{T})$, is equal to $\max_{t \in V(T)} |X_t| - 1$. The treewidth of a graph $G$, denoted as $\textrm{tw}(G)$, is the minimal width over all tree decompositions of $G$.
\\\\
A nice tree decomposition of a graph $G$ is a tree decomposition $(T, \{X_t\}_{t \in V(T)})$ such that
\begin{itemize}
	\item $X_i = \emptyset$ if $i$ is either root or leaf.
	\item Every non-leaf node is of one of the three following types:
	\begin{itemize}
		\item \textbf{Introduce node}: a node $t$ with exactly one child $t'$ such that $X_t = X_{t'} \cup \{v\}$ for some vertex $v \notin X_{t'}$.
		\item \textbf{Forget node}: a node $t$ with exactly one child $t'$ such that $X_t = X_{t'} \setminus \{w\}$ for some vertex $w \in X_{t'}$
		\item \textbf{Join node}: a node $t$ with exactly two children $t_1$, $t_2$ such that $X_t = X_{t_1} = X_{t_2}$.
	\end{itemize}
\end{itemize}

We distinguish one special case. If a tree $\mathcal{T}$ forms a path, we call it a \emph{path decomposition}. Respectively, by $\textrm{pw}(G)$ we denote a width of a path decomposition and by $\textrm{pw}(G)$ we denote the minimal width over all path decompositions of $G$.

\chapter{Spanning Star Forest Problem}

In this chapter we examine both decision and constructive variant of \ssfp{}. We propose an algorithm working in linear time that outputs a \ssf{} or concludes with a NO-instance.

\section{Decision variant (??)}

It turns out that the problem formulated in such a way is relatively simple. Although, various variants described in this paper make it more complex. The following lemma easily clarifies all the concerns about its hardness.

\begin{lemma}\label{SSF lemma}
 A graph $G$ has a \ssf{} if and only if it does not contain any isolated vertices.
\end{lemma}

\begin{proof}
	If $G$ has a \ssf{} $S$, then trivially for all $v \in V(G)\ 1 \leq deg_S(v) \leq deg_G(v)$. Thus, none of the vertices is isolated.
	
	For the opposite direction, we prove the lemma by induction on $|V(G)|$. Assume $|V(G)|=2$. The statement trivially holds because a graph consisting of one edge and two vertices is a correct \ssf{}. Let $|V(G)| >2$. For the inductive step, we split the proof into two parts. Firstly, suppose that for all vertices $v \in V(G)$, it holds that $\degree{G}{v}=1$.  Clearly, $G$ is a matching. Hence, it is a correct \ssf{}. Now, suppose that there exists a vertex $u$ such that $\degree{G}{u}>1$. Let $C \subseteq G$ be a connected component satisfying $u \in V(C)$. Based on the degree of $u$, we infer that $|V(C)|>2$. Let $T$ be an arbitrary spanning tree of $C$ and $v$ be one of its leaf. Thus, $T \setminus v$ is a spanning tree of $C \setminus v$. So, $C \setminus v$ does not have an isolated vertex and neither has the graph $G \setminus v$. From the induction, let $S$ be a \ssf{} of the graph $G \setminus v$, $u$ vertex such that $uv \in E(G)$ and take any $w \in N_S[u]$. Consider the two following cases:
	\begin{enumerate}
		\item Suppose $u$ is a ray in $S$. This implies that $w$ is a center and $deg_S(w) \geq 2$. Then, $S'=\big(V(S) \cup \{v\},(E(S) \cup \{uv\}) \setminus \{uw\}\big)$ is a spanning star forest for the graph $G$.
		\item Otherwise, $u$ is either a candidate or a center. Then, $S'=\big(V(S) \cup \{v\}, E(S) \cup \{uv\}\big)$ is a spanning star forest for the graph $G$.
	\end{enumerate}
	
\end{proof}

Application of Lemma \ref{SSF lemma} yields the following result for \ssfp{}.

\begin{corollary}
	\ssfp{} can be solved in linear time.
\end{corollary}

\begin{proof}
	Given a graph $G = (V,E)$ the answer is YES if for all $v \in V(G)\ \degree{G}{v} \neq 0$ and NO otherwise.
\end{proof}

\section{Constructing a solution}

In this section we focus on obtaining an arbitrary solution for a given instance of \ssfp{}. Firstly, let us introduce two claims which help to normalize an instance and make the algorithm more clear.

\begin{claim} \label{SSF sum}
	If $C_1,C_2,...C_n$ are the connected components of a graph $G$ and $S_1,S_2,...,S_n$ its \ssf{}s respectively, then $\bigcup\limits_{i=1}^n S_i$ is a \ssf{} of $G$.
\end{claim}

\begin{claim} \label{Spanning tree SSF}
	A connected graph $G$ has a \ssf{} if and only if its spanning tree $T$ has.
\end{claim}

The first claim can be trivially proven by the definition of a \ssf{} while the second one follows directly from Lemma \ref{SSF lemma}. Equipped with this information, all that is left to do, is to design an algorithm which solves the problem for trees.

\begin{algorithm}\label{alg1}
	\KwIn{connected graph $G$ such that $V(G) \geq 2$}
	\KwOut{\ssf{} of $G$}
	$\textrm{spanned} \leftarrow \textrm{Array}[|V(G)|]$\; 
	$T \leftarrow$ $\textrm{SpanningTree}(G)$\;
	$S \leftarrow$ $\emptyset$\;
	\For{$v$: $\textrm{postorder}(T)$ and $v$ is not a root}{
		\If{$!\textrm{spanned}[v]$}{
			$u \leftarrow \textrm{parent}(T,v)$\;
			$S \leftarrow S \cup \{(u,v)\}$\;
			$\textrm{spanned}[v] = True$\;
			$\textrm{spanned}[u] = True$\;
		}
	}
	$v \leftarrow root(T)$\;
	\If{$!\textrm{spanned}[v]$}{
		$S \leftarrow S \cup \{(u,v)\}$ where $v = \textrm{parent}(T,u)$ is a child of $v$\;
	}
	\Return $S$\;
	\caption{Obtaining a spanning star forest from a connected graph.}
\end{algorithm}

Firstly, the algorithm creates a spanning tree $T$. Then, it does a simple bottom-up traversal. If the current node $v$ has not been added to the solution yet, the algorithm adds the edge connected to its parent. If the root has not been added to the solution during the for loop, we add an arbitrary edge, incident to the solution, which finishes the algorithm. If the input graph is not connected, we run the algorithm separately on each component and then merge results based on Claim \ref{SSF sum}.

Now we need to check if the obtained graph is a spanning star forest. There is one non-trivial operation that the algorithm does. Specifically, if the root has not  been added during the for loop, we connect the root to any existing star without checking whether it remains a correct star. Before we proceed to the main lemma about the correctness of Algorithm \ref{alg1}, let us prove the following claim:

\begin{claim}\label{ssf root}
	Suppose that a connected graph $G$ is the input for Algorithm \ref{alg1}. Let $T$ be a spanning tree obtained during $SpanningTree(G)$ procedure and $S$ be the output graph. If $u_1 u_2,u_2 u_3 \in E(S)$, $u_2 = \textrm{parent}(T,u_1)$ and $u_3=\textrm{parent}(T,u_2)$, then $u_3$ is the root and $|N_S[u_3]|=1$.
\end{claim}

\begin{proof}
	Observe that no two consecutive parents can be added during for loop. Thus, edge $u_2 u_3$ must have been added in if statement. Since $u_3 = \textrm{parent}(T,u_2)$, $u_3$ must be the root. Moreover, having known that the root appears in $S$ for the first time during if statement, we conclude that $|N_S[u_3]|=1$. 
\end{proof}

\begin{lemma}\label{alg1 correctness}
	Algorithm \ref{alg1} ran on a connected graph $G$, satisfying $|V(G)| \geq 2$, outputs a spanning star forest $S$.
\end{lemma}

\begin{proof}
	To prove the following lemma we need to show that all of the four following conditions hold after a successful execution of the algorithm:
	\begin{enumerate}
		\item $S$ does not consist of any cycle.
		\item $S$ spans $G$ i.e. $V(S) = V(G)$.
		\item $S$ does not have any isolated vertices.
		\item $S$ does not consist of a path of size $3$.
	\end{enumerate}
	Trivially, $S$ does not contain a cycle because $S$ is a subgraph of $T$ which is a tree. Now, observe that the algorithm iterates over all vertices and, except for the root, pairs every vertex with its parent. The last pair, root and its child, is added either in a for loop or in if statement. Thus, we conclude that $S$ does not have any isolated vertices. Ultimately, we prove that $S$ does not consist of a path of size $3$. From the Claim \ref{ssf root} we infer that no two consecutive parents are added to the solution unless the last node is the root. In addition, root has exactly one neighbor. Therefore, $S$ does not contain a path of size $3$.
\end{proof}

Having proven the correctness of Algorithm \ref{alg1} we proceed to the complexity analysis i.e. we prove the Theorem \ref{thm-ssfp}.

\begin{proof}[Proof (of Theorem \ref{thm-ssfp})]
	An arbitrary spanning tree of any graph can be found in linear time. The main loop has $n-1$ iterations (every vertex is processed once), each of which takes constant time.
	Thus, the total runtime is linear.
\end{proof}

The problem stated without any constraints is simple. Both decision and constructive variants of the problem can be solved in linear time. The next ones, studied in this paper, yield more complex results.

\chapter{Minimal Spanning Star Forest problem}

In \mssfp{}, given a graph $G$ and a natural number $k$, the objective is to determine whether there exists a \ssf{} $S$ such that the number of connected components is at most $k$.

It is natural to ask whether one can find a solution that minimizes the number of connected components. The problem formulated in that way looks slightly different than the previous one. From the other hand, the problem resembles \domsetp{}.

At first glance, one can say that a center corresponds to a dominating vertex whereas a ray is corresponds to a dominated vertex. Candidates might be represented by either a dominating or dominated vertex. However, in \domsetp{} isolated dominating vertices are allowed and some vertices are dominated by multiple neighbors. 

To give a systematic parameterized reduction between these two problems, we need to get a better understanding of the \domsetp{} problem.

\begin{definition}
	Given a graph $G$ and a dominating set $D$, a {\normalfont domination mapping} is a function $\mu:V(G) \setminus D \rightarrow D$ such that satisfies $(x,\mu(x)) \in E(G)$ for all $x \in Dom(\mu)$.
\end{definition}

\begin{lemma}\label{dom mapping}
	Let $G$ be a graph without isolated vertices and let $D$ be a dominating set in $G$ of minimum size. Then, there exists a domination mapping $\mu$ such that $\mu$ is surjective.
\end{lemma}

\begin{proof}
	Let $\mu$ be a dominating mapping that maximizes $|\Ima \mu|$. If $\mu$ is surjective, then the proof is finished. Otherwise, there exists a vertex $v \in D$ such that $v \notin \Ima \mu$. Consider the following cases:
	\begin{enumerate}
		\item Suppose $N_G(v) = \emptyset$. Contradiction, $G$ has no isolated vertices. Let $u$ be any neighbor of $v$.
		\item Suppose $u \in D$. Contradiction, $D$ was assumed to be a solution of minimal size whereas $D \setminus \{v\}$ is a smaller dominating set.
		\item Suppose $u \notin D$ and let $w = \mu(u)$. If $|\mu^{-1}(w)|=1$, then $((D \setminus \{v,w\}) \cup u)$ is a smaller dominating set for the graph $G$. Contradiction.
		\item Finally, suppose $|\mu^{-1}(w)| > 1$ then the mapping:
		\begin{equation*}
			\mu'(x) = \begin{cases}
			v, & \text{if }x = u \\
			\mu(x), &\text{otherwise} \\
			\end{cases}
		\end{equation*}
		is a valid domination mapping that satisfies $\Ima \mu \subsetneq \Ima \mu'$. Contradiction, we assumed that $\mu$ is a dominating mapping that maximizes $|\Ima \mu|$.
	\end{enumerate}
	
	Since all the cases led to a contradiction we conclude that there exists a domination mapping $\mu$ such that $\mu$ is surjective.  
\end{proof}

Armed with the lemma, we are ready to show the reduction:

\begin{theorem}\label{dom-ssf reduction}
	There exists a parameterized reduction that takes an instance $(G,k)$ of \domsetp{} and returns an instance $(G',k)$ of \mssfp{} such that $|V(G')| \leq 2 \cdot |V(G)|$. 
\end{theorem}

\begin{proof}
	Firstly, we show the reduction. Given a graph $G$ and integer $k$, for every isolated vertex $v \in V(G)$ we introduce a vertex $v'$ and an edge $(v,v')$. Now, we claim that $(G,k)$ is a YES-instance of \domsetp{} if and only if $(G',k)$ is a YES-instance of \mssfp{}. 
	
	Consider the backward implication. Suppose $S$ is a solution for $(G',k)$. We create the \domset{} $D$ as follows: for every isolated edge $vu$ such that $vu \notin E(G)$ pick a vertex $v \in V(G)$, for every other star in $S$ of size $2$ pick an arbitrary candidate and for every star of size greater than $2$ pick a center. Note that $D \subseteq V(G)$ because we explicitly excluded all the vertices introduced in $G'$. Obviously, $|D| \leq k$ because there are at most $k$ stars in $S$. Observe that every isolated vertex $v \in V(G)$ is in $D$. Finally, observe that every vertex $v \in V(G) \setminus D$ satisfies $v \in V(G')$. So, $v$ is either a ray or a candidate. It means that there exists an edge to one of the centers or candidates that were added to $D$.
	
	To prove the forward implication, let $D$ be a minimum size dominating set for $(G,k)$. Obviously, $D$ is also a minimum dominating set for the graph $G'$ as $D$ contains isolated vertices that dominate vertices introduced in $G'$. Thus, by Lemma \ref{dom mapping}, there exists a domination mapping $\mu$ that is surjective. Now, we claim that the graph $S=(V(G'),\{x\mu(x): x \in V(G) \setminus D\})$ is a correct solution for the instance $(G',k)$ of \mssfp{}. By surjectivity, there are no isolated vertices in $S$ because dominated vertices are paired with dominating ones. Moreover, $S$ is a spanning star forest because $\mu$ maps vertices from $V(G') \setminus D$ to $D$ and for all $v \in V(G') \setminus D$, $\degree{S}{v}=1$.
	
\end{proof}

The above reduction immediately proves Theorem \ref{thm-mssfp-w2c} stated in the introduction.

\begin{proof}[Proof (of Theorem \ref{thm-mssfp-w2c})]
	Observe that \domsetp{} is a W[2]-complete problem. Thus, by Lemma \ref{dom-ssf reduction}, there exists a parameterized reduction from a \domsetp{} problem to a \mssfp{}.
\end{proof}

Observe that the parameterized reduction can be easily transformed to a regular one. Since \domsetp{} is an NP-complete problem, we can also formulate the following corollary:

\begin{corollary}
	\mssfp{} is NP-complete.
\end{corollary}

\begin{proof}
	We can prove hardness of the problem by a reduction from \domsetp{} stated in Lemma \ref{dom-ssf reduction}.
\end{proof}

The problems look so similar that one could ask whether the reverse reduction is true. Indeed, with a slight change in the input instance, one can prove the reverse reduction instantly.

\begin{lemma}\label{ssf-dom reduction}
	There exists a parameterized reduction that takes an instance $(G,k)$ of \mssfp{} and returns an instance $(G,k')$ of \domset{} such that $k' \leq k$. 
\end{lemma}

\begin{proof}
	Let $(G,k)$ be an instance of \mssfp{}. If $G$ contains an isolated vertex, then return $(G,0)$. Otherwise, return $(G,k)$. Now, we claim that $(G,k)$ is a YES-instance for \mssfp{} if and only if $(G,k')$ is a YES-instance for \domset where $k'=0$ or $k'=k$.
	
	Consider the forward implication. Let $S$ be a spanning star forest of at most $k$ stars for the graph $G$. Observe, that $G$ does not change during the reduction. We create a dominating set $D$ as follows: for every star of size $2$ pick an arbitrary candidate, and for every star of size at least $3$ pick a center. Obviously, $|D| \leq k$ because $S$ contains at most $k$ stars. So, suppose that there exists $v \in V(G) \setminus D$ that is not dominated. However, $S$ spans $G$ which means that $v$ is in one of the stars. Therefore, not only $v$ is either a ray or a candidate but also there exists an edge $vu \in E(S)$ such that $u$ is either a center or a candidate. By the definition of $D$, $u \in D$. Contradiction because $u$ dominates $v$.
	
	For the backward implication, let $D$ be a minimum size dominating set for $(G,k)$. By Lemma \ref{dom mapping}, there exists a domination mapping $\mu$ such that $\mu$ is surjective. Now, we claim that the graph $S$ = $(V(G), \{x\mu(x): x \in V(G) \setminus D\})$ is a spanning star forest. Obviously, $S$ spans $G$ as it contains all the vertices from $G$. Moreover, there are no isolated vertices because for every vertex $v \in V(G) \setminus D$ there exists exactly one vertex $u \in D$ such that $vu \in E(S)$ and for every vertex $u \in D$ there exists at least one vertex $v \in V(G) \setminus D$ such that $vu \in E(S)$. From the previous sentence we can also infer that the mapping forces every connected component to be a star that concludes the proof.
\end{proof}

Since there exist parameterized reductions from one problem to the other, we obtain the following corollary:

\begin{corollary}
	\domsetp{} and \mssfp{} are \textrm{interreducible}.
\end{corollary}

Interreducibility is a strong and useful tool. Especially, if only one of the problems has been deeply studied in the past. As an example, we transfer a lower bound for runtime from \domsetp{} to \mssfp{}. Consider the following theorem proven in \textit{Parameterized Algorithms} book:

\begin{theorem}\label{domset-seth}
	Unless \cnfsat{} cannot be solved in time $\mathcal{O}^*((2-\epsilon')^n)$ for some $\epsilon' > 0$, there does not exist constants $\epsilon > 0, k \geq 3$ and an algorithm solving \domsetp{} on instance with parameter equal to $k$ that run in time $\mathcal{O}(N^{k-\epsilon})$, where $N$ is the number of vertices of the input graph.
\end{theorem}

%TODO dowod.

%TODO DO WE NEED THIS?
\iffalse

Consider the following brute force algorithm that solves \mssfp{}:

\begin{algorithm}\label{alg2}
	\KwIn{Graph $G$ and integer $k$}
	\KwOut{\ssf{} of $G$ of at most $k$ stars}
	\If{$G$ has an isolated vertex}{
		\Return NO-instance\;
	}
	\If{$k \leq \frac{n}{2}$}{
		\Return YES-instance\;
	}
	\For{$i: 0\dots k$}{
		\For{$D \in \{C: C \subseteq V(G) \text{ and } |C|=i\}$}{
			\If{$D$ is a dominating set for $G$}{
				\Return YES-instance\;
			}
		}
	}
	\Return NO-instance\;
	\caption{Algorithm solving \mssfp{}}
\end{algorithm}

Firstly, Algorithm \ref{alg2} does two simple checks: whether the input graph has an isolated vertex and then whether the parameter is greater than half of the size of the graph. If none of the conditions is satisfied, then it iterates over all subsets of vertices of size smaller than $k$. If one of the sets is a dominating set, then it is a YES-instance. Otherwise, there does not exist a \ssf{} of size at most $k$. The following lemma formally proves the intuition:

\begin{lemma}
	Given an input $(G,k)$ of \mssfp{} the Algorithm \ref{alg2} decides whether there exists a \ssf{} of $k$ stars.
\end{lemma}

\begin{proof}
	Obviously, the algorithm correctly decides when the input graph contains an isolated vertex. If the parameter is greater than half of the size of the graph that does not have an isolated vertex, then it is a YES-instance. Observe that a graph can be spanned by at most $\frac{|V(G)|}{2}$ stars because every star has at least $2$ vertices. Therefore, by Lemma \ref{SSF lemma}, we conclude that an instance without isolated vertices and a parameter greater than half of the size of graph is a YES-instance. After all, let us focus on the last part. We need to prove that a graph with no isolated vertices has a \ssf{} of at most $k$ stars if and only if it has a dominating set of at most $k$ vertices. The equivalence is simply proven by Lemma \ref{ssf-dom reduction}. Observe that the parameterized reduction does not change the input graph nor the parameter if the graph does not contain an isolated vertex. Therefore, finding a \ssf{} of size at most $k$ is equivalent to finding a dominating set of size at most $k$.
\end{proof}

Having shown the correctness of Algorithm \ref{alg2} we now proceed to the complexity analysis.

\begin{lemma}\label{alg2-time}
	Algorithm \ref{alg2} returns the answer in time $\mathcal{O}^*(n^k)$.
\end{lemma}

\begin{proof}
	Firstly let us constrain the number of iterations: $\sum\limits_{i=0}^{k} {n \choose i} \leq (k+1) \cdot {n \choose k} \leq (k+1) \cdot n^k$. Note that the first inequality is true because $k \leq \frac{n}{2}$ and so ${n \choose k} \leq {n  \choose \frac{n}{2}}$. We can decide whether a set is a dominating set in polynomial time. Thus, the total runtime is equal to $\mathcal{O}^*((k+1)n^k \cdot \textrm{poly}(n))=\mathcal{O}^*(n^k)$.
\end{proof}

Finally, we can prove the theorem stated in the introduction:

\begin{proof}[Proof (of Theorem \ref{thm-mssfp-time})]
	Lemma \ref{alg2-time} proves that the Algorithm \ref{alg2} solves the \mssfp{} in time requested in the theorem.
\end{proof}

Now, we prove that asymptotically, there does not exist a faster algorithm assuming that SETH holds. We

\fi

\chapter{Spanning Star Forest Extension}

In this chapter, we significantly change the problem. Let $G$ be a graph and $F \subseteq E(G)$ be a set of \emph{forced edges}. In the \ssfep{} the question, that we want to answer now, is whether there exists a \ssf{} $S$ such that $F \subseteq E(S)$. We used three different parameters: number of forced edges, number of free edges and treewidth. 

\section{Preliminaries}

\subsection{Notation}

In further, we denote by $F$ a set of \emph{forced edges}. Vertices that have exactly one forced edge are called \emph{forced candidates}. Similarly, if a subset of $F$ forms a \emph{forced star} of size greater than $3$ we call its particles a \emph{forced center} and \emph{forced rays} consequently. We denote by $F_R$ a set of all forced rays and by $F_C$ a set of all forced centers. Vertices that does not belong to $V(F)$ are called \emph{free vertices} and they are denoted by $U$.

\subsection{Instance normalization} 

Notice that this time we do not have any limit on the number of connected components. The hardness of the problem lies in choosing which of the forced candidates should become a forced center and which one should become a forced ray. Also, observe that a star is a primitive structure. The star's maximal radius is equal to $2$. It means that we can look at the problem rather locally than globally. Thus, it is possible to normalize instances i.e. try to remove vertices that are "far enough" from forced vertices.

\begin{definition}\label{norm-ssfe}
	A pair $(G,F)$ is normalized if the following conditions hold:
	\begin{enumerate}
		\item $G$ does not have isolated vertices.
		\item $F$ is an induced matching.
		\item $\forall_{u \in U}\ N_G[u] \subseteq V(F)$.
	\end{enumerate}
\end{definition}

Surprisingly, except for two trivial cases, all of the instances of \ssfep{} can be normalized. We begin by showing cases for which we conclude with NO-instance:
\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},labelindent=0pt]
	\item If graph $G$ contains an isolated vertex, then it is a NO-instance.
\end{enumerate}

Obviously, an isolated vertex cannot be a star. Now, observe that in the extension variant there exists a set of edges that must be added to the solution. Therefore, we can instantly conclude with a NO-instance if $F$ contains a forbidden subgraph.

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},labelindent=0pt,resume]
	\item If $F$ contains a path or a cycle of size at least $3$, then it is a NO-instance.
\end{enumerate}

Now, let us show three rules. After exhaustive application, they return a set of forced edges that is an induced matching. Firstly, we remove free edges between forced vertices:

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},labelindent=0pt,resume]
	\item Remove the set of edges $\{vu: v,u \in V(F),\ vu \in E(S) \setminus F\}$.
\end{enumerate}

Clearly, if such an edge existed in a solution, that would mean that the solution contains either a path or a cycle of size $3$. Now, suppose that a subset of forced edges forms a star of size at least $3$. Then, the forced center is already determined. Thus, we can remove from the instance all the free edges that that have at least one end in a forced ray. 

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume,wide, labelwidth=!, labelindent=0pt]
	\item Remove the set of edges $\{uv: u \in F_R,\ uv \in E(G) \setminus F\}$
\end{enumerate}

We claim that the operation is safe. To prove it, suppose contrary. Let $u \in V(G)$, $v \in F_R$ and $uv \in E(G) \setminus F$. Now, suppose that there exists a solution $S$ such that $uv \in E(S)$. However, $v$ is a forced ray. So, there exists a vertex $c \in F_C$ and $v' \in F_R$, such that $v \neq v'$ and $vc,cv' \in F$. Moreover, $vc,cv' \in E(S)$. Therefore $S$ contains a path of size $3$, namely, $uv,vc,cv'$. Thus, $S$ is not a spanning star forest.

Observe that after exhaustive application of the above rule, every $v \in F_R$ satisfies $\degree{G}{v}=1$. Every forced ray is connected to its forced center only. Hence, for every forced star of size greater than $2$ we can remove all forced rays except for one.

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume,wide, labelwidth=!, labelindent=0pt]
	\item Suppose that $(G,F)$ is the output graph after exhaustive application of the previous reduction. For every forced star of size greater than $2$, remove all the forced rays except for one.
\end{enumerate}

The safeness argument is simple. For the sake of contradiction, let $S$ be a solution such that a former forced ray $v$ is now a center in $S$. However, after Reduction 3 we infer that $\degree{S}{v} = \degree{G}{v} = 1$. Thus, $v$ is either a ray or a candidate in $S$. Contradiction.

Let us summarize the work and infer how an input graph looks like now:

\begin{claim}
	Given an instance $(G,F)$, if Reduction 2 does not yield a NO-instance, then exhaustive application of Reductions 3-5 outputs $(G',F')$ such that $F'$ is an induced matching.
\end{claim}

\begin{proof}
	We prove the claim by contradiction. Firstly, suppose that $F$ is not a matching. Hence, there exists a connected component of size greater than $2$. It must be a star because Reduction 2 does not yield a NO-instance. Contradiction, we did not apply exhaustively Reduction 5 to decrease the size of each forced star. Now, suppose that $F$ is not an induced matching, that is, $F \subsetneq E(G[V(F)])$. Therefore, there exist $u,v \in V(F)$ such that $uv \in E(G) \setminus F$. Contradiction, Reduction 3 has not been applied exhaustively.
\end{proof}

Now, let us focus on the second part of the graph i.e. free vertices. As we have already seen, by Lemma \ref{SSF lemma}, there exists a spanning star forest if and only if there are no isolated vertices. Let $V_P = \{u: (u,v) \in (E(G) \setminus F) \text{ and } u,v \in U\}$ and $V_{NP} = V(G) \setminus V_P$. Finally, $G_{NP} = G[V_{NP}]$ and $G_P = G[V_P]$. Now, we claim that:

\begin{claim}
	$G_P$ has a spanning star forest.
\end{claim}

\begin{proof}
	$G_P$ does not have any forced edges. Moreover, every vertex has at least neighbor that is also a free vertex. Hence, by Lemma \ref{SSF lemma} $G_P$ has a spanning star forest.
\end{proof}

Observe that during partitioning we lose the information about some edges. Specifically, let $L= \{vu: uv \in E(G), v \in V(G_{NP}),\ u \in V(G_P)\}$ be the set. Notice that vertices from $G_{NP}$ are the forced vertices. Also, both forced vertices and vertices from $G_P$ are already satisfied i.e. we can always span them by a star forest. Therefore, we can formally state the last claim of this section:

\begin{claim}\label{GNP partition}
	An instance $(G,F)$ has a solution if and only if $(G_{NP},F)$ has one.
\end{claim}

\begin{proof}
	For the backward implication, suppose $S$ is a solution for $(G_{NP},F)$. We can partition $G$ into $G_P$ and $G_{NP}$ and find a solution, say $S'$, for the graph $G_P$. Then, $S \cup S'$ is a correct solution for $G$.
	
	Now, consider the forward implication. Let $S$ be a solution for $(G, F)$ and let $S' = S \cap E(G_{NP})$ be a subgraph restricted to the edges of $G_{NP}$ only. Observe that $S'$ is a correct star forst. If $S'$ is a spanning star forest for $G_{NP}$ then we conclude. Otherwise, there exists a vertex $v$ such that $v \in V(G_{NP}) \setminus V(S')$. $v$ must be a free vertex because all the forced vertices are spanned by forced edges from $F$. However, $\degree{G}{v}=\degree{G_{NP}}{v}$ because the set of $v$'s neighbors consists of forced vertices. Hence, $v \notin V(S)$ which means that $S$ is not a spanning star forest for $G$. Contradiction.
\end{proof}

Finally, we are ready to state the last reduction rule:

\begin{enumerate}[leftmargin=*,label=\textbf{Reduction \arabic{enumi}},resume,wide, labelwidth=!, labelindent=0pt]
	\item Update $G=G_{NP}$.
\end{enumerate}

Note that the instance obtained after the application of Reduction 6 satisfies the last condition from Definition \ref{norm-ssfe}. Hence, we formally state the normalization lemma:

\begin{lemma}
	Let $(G,F)$ be an instance of \ssfep{}. There exists a polynomial reduction that the exhaustive application concludes with a NO-instance or outputs an equivalent normalized instance $(G',F')$ satisfying $G' \subseteq G$ and $F' \subseteq F$.
\end{lemma}

\begin{proof}
	Exhaustive application of Reductions 1-6 outputs a normalized instance. Clearly, it takes polynomial time to finish because graph traversal as well as vertex/edge removal can be done in polynomial time.
\end{proof}

Ultimately, we want to point out one advantage of having a normalized instance of \ssfep{}. Namely, consider the following claim:

\begin{claim}
	Let $(G,F)$ be a normalized instance of \ssfep{} and let $C \subseteq V(F)$ be an independent set. If $U \subseteq N[C]$, then there exists a spanning star forest for $(G,F)$.
\end{claim}

\begin{proof}
	Firstly, observe that $F$ is an induced matching. Thus, every forced edge is a single star. If $U \subseteq N[C]$ it means that for every $v \in U$ there exists a vertex $u \in C$ such that $vu \in E(G)$. Thus, we can add every free vertex to one of the existing stars. Now, suppose $S \subseteq G$ is a subgraph that takes all the forced edges and, for every free vertex, adds exactly one edge to a forced vertex from $C$. Observe that in $S$, for every $uv \in F$, the degree of at most one vertex is greater than $1$. Thus, $S$ is spanning star forest for $(G,F)$.
\end{proof}

\section{NP-completeness}

Let $(G,F)$ be an instance of \ssfep{} after normalization. Then, $G$ consists of vertices of two types: ones that have edges to vertices from $V(F)$ only and ones that have exactly one forced edge (and potentially many free ones). Such a representation substantially simplifies further investigations. Indeed, we can show a reduction from \cnfsat{}.

\begin{lemma}\label{ssfep reduction}
	There exists a polynomial time reduction that takes an instance $\phi$ of \cnfsat{}, such that $\phi$ has $n$ variables and $m$ clauses, and returns a normalized instance $(G,F)$ of \ssfep{} such that $|V(G)|=2n+m$ and $|F|=n$.
\end{lemma}

\begin{proof}
	Firstly, we show a reduction. Suppose $\phi$ is an arbitrary instance of \cnfsat{}. $\phi$ is a CNF formula, so let $\textrm{Clauses}=\{C_1,...,C_m\}$ be the set of clauses and let $\textrm{Variables}=\{x_1,...,x_n\}$ be the set of variables from $\phi$. For every clause $C_i$ we introduce a vertex $v[C_i]$ and for every variable $x_i$ we introduce two vertices $v[x_i],v[\neg x_i]$ and a forced edge $v[x_i]v[\neg x_i]$. Observe that the graph consists of $2n+m$ vertices and $n$ forced edges. Now, for every occurrence of a literal $l_i$ in a clause $C_j$ we introduce a free edge $v[C_j]v[l_i]$. Finally, we say that $(G,F)$, the graph that we described, has a spanning star forest if and only if there exists a satisfiable evaluation of the formula $\phi$.
	
	Before we begin the proof, observe that $(G,F)$ is a normalized instance. Firstly, there are no isolated vertices because every clause has at least one literal. Secondly, $F$ is an induced matching because vertices introduced for literals (forced vertices) are connected to vertices introduced for clauses (free vertices) only. And finally, no edges were introduced between vertices introduced for clauses (free vertices).
	
	For the forward implication, let $S$ be a solution for $(G,F)$. We create an evaluation $\sigma$ as follows:
	
	\begin{equation*}
		\sigma(x_i) = 
		\begin{cases}
			\textrm{True}\text{, if $\degree{S}{v[x_i]} > 1$} \\
			\textrm{False}\text{, otherwise}
		\end{cases}
	\end{equation*}
	We claim that the evaluation satisfies $\phi$. However, suppose contrary, that $\sigma(\phi)=\textrm{False}$. It means that there exists a clause $C_i \in \textrm{Clauses}$ such that $\sigma(C_i)=\textrm{False}$. Notice that $S$ is a spanning star forest for the graph $G$. Thus, there exists a vertex $v[l_j]$ such that $N_S[v[C_i]] = \{v[l_j]\}$. Moreover, the literal $l_j$ occurs in the clause $C_i$ by the definition of the graph $G$. Now, observe that $\degree{S}{v[l_j]} > 1$. Hence, $\sigma(l_j)=\textrm{True}$. Based on that, we infer that $\sigma(C_i)=\textrm{True}$. Contradiction. Evaluation $\sigma$ satisfies $\phi$.
	
	To prove the backward implication, assume there exists an evaluation $\sigma$ of variables that satisfies the formula. If $\sigma(\phi)=\textrm{True}$, then for every $C_i \in \textrm{Clauses}$, $\sigma(C_i)=\textrm{True}$. Moreover, for every $C_i \in \textrm{Clauses}$ there exists a literal $l_i \in C_i$ such that $\sigma(l_i)=1$. Now, let $S' = (V(G), F \cup \{v[C_i]v[l_i]: v[C_i]v[l_i] \in E(G) \text{ and } \sigma(l_i)=1\})$. Note that $\degree{S'}{v[C_i]}>1$ for every $C_i \in \textrm{Clauses}$ because in every clause there exists at least one literal $l_k$ that evaluates to $\textrm{True}$. Finally, let $S \subseteq S'$ be an arbitrary subgraph such that $V(S)=V(S')$, $F \subseteq E(S)$ and $\degree{S}{v[C_i]}=1$ for every $C_i \in \textrm{Clauses}$. Now, we claim that $S$ is a spanning star forest for $G$. Indeed, by the definition of $S$, $\degree{S}{C_i}=1$ and for every variable $x_i$ $\degree{S}{x_i}=1$ or $\degree{S}{\neg x_i}=1$. Recall, that $(G,F)$ is a normalized instance. Hence, $|F|$ is an induced matching. Thus, we conclude that $S$ is a spanning star forest for $G$.
\end{proof}

There is one more observation that we want to point out in this section. Since a CNF-formula is trivially encoded as a spanning star forest extension instance, one can ask if the problems are interreducible. Indeed, it is true and we present the backward reduction. Note that we consider normalized instances only.

\begin{lemma}\label{cnfsat reduction}
	There exists a polynomial time reduction that takes an instance $(G,F)$, such that $(G,F)$ has $n$ forced edges and $m$ free vertices, and returns a formula $\phi$ of \cnfsat{} such that $\phi$ has at most $n$ variables and $m$ clauses.
\end{lemma}

\begin{proof}
	Firstly, we apply Lemma \ref{norm-ssfe} to normalize the instance. If it yields a no instance, we return a formula $(x \land \neg x)$. Otherwise, let $(G',F')$ be the output of the reduction rules. Observe that $G' \subseteq G$ and $F' \subseteq F$. Now, we proceed to a formula construction. For every forced edge $vu$ we introduce a variable $x_{vu}$ and we arbitrarily label its ends as $x_{vu}$ and $\neg x_{vu}$. Now, for every free vertex $w$ we introduce a clause $C_w$. Moreover, every clause $C_w$ consists of a disjunction of literals $\textrm{labels}(N_G(w))$. Finally, we claim that $(G,F)$ has a spanning star forest if and only if the formula $\phi$, described above, is satisfiable.
	
	Observe that the instances are equivalent to the instances described in Lemma \ref{ssfep reduction}. One can follow the schema from the previous reduction.
\end{proof}

Ultimately, we can prove the main theorem of the section:

\begin{proof}[Proof (of Theorem \ref{thm-ssfep-npc})]
	We apply a reduction described in Lemma \ref{ssfep reduction} from an NP-complete problem, that is, \cnfsat{}.
\end{proof}

\section{Parametrization by the number of forced edges}

In this section, in addition to an instance $(G,F)$ we receive a parameter $k$ which is equal to a number of forced edges. We show two major results: \ssfep{} parameterized by the number of forced edges does not admit a kernel of polynomial size and a lower bound under Strong Exponential Hypothesis.

\subsection{Cross-composition}

A \emph{cross-composition} is a framework for proving kernelization lower bounds. A technique, firstly introduced in 2008 by Bodleander et al. (ICALP 2008), has significantly increased the interest in kernelization. As a result, Bodleander, Jansen and Kratsch have published a straightforward schema to show a nonexistence of a kernel.

The following definitions and corollary are taken from \textit{Parameterized Complexity} book. %TODO paper name%.

\begin{definition}\label{polynomial equivalence relation}
	An equivalence relation $\mathcal{R}$ on $\Sigma^*$ is called a \textup{polynomial equivalence relation} if the following conditions hold:
	\begin{enumerate}
		\item There exists an algorithm $\mathcal{A}$ such that given given $x,y \in \Sigma^*$ decides whether $x \equiv_{\mathcal{R}} y$ in time $p(|x|+|y|)$ for a polynomial $p$..
		\item Relation $\mathcal{R}$ restricted to the set $\Sigma^{\leq n}$ has at most polynomially many equivalence classes.
	\end{enumerate}
\end{definition}

\begin{definition}\label{cross-composition}
	Let $L \subseteq \Sigma^*$ be a language, $\mathcal{R}$ be an equivalence relation $Q \subseteq \Sigma^* \times \mathbb{N}$ be a parameterized problem. A \textup{cross-composition} of a language $L$ into $Q$ is an algorithm $\mathcal{A}$ that given an input $x_1,...,x_t \in L$, equivalent with respect to $\mathcal{R}$, outputs an instance $(x,k') \in \Sigma^* \times \mathbb{N}$ such that:
	\begin{enumerate}
		\item $k \leq p(\max\limits_{1 \leq i \leq t} |x_i| + log(t))$ for a polynomial $p$.
		\item $(x,k') \in Q$ if and only if there exists an index $i$ such that $x_i \in L$.
	\end{enumerate}
\end{definition}

\begin{corollary}\label{nokernel}
	If an NP-hard language $L$ cross-composes into the parameterized language $Q$, then $Q$ does not admit a polynomial kernel unless \textup{NP$\subseteq$ coNP/poly}.
\end{corollary}

\subsection{Lower bound for a kernel}

In this section, we prove that \ssfep{} parameterized by the number of forced edges does not admit a polynomial kernel unless NP $\subseteq$ coNP/poly. To achieve this, we show two different approaches. Firstly, we show a proof based on nonexistence of a polynomial kernel for \cnfsat{} parameterized by the number of variables. Then,  we prove it by a cross-composition from \ssfep{} into itself. The second proof is not feasible. We use an \emph{instance selector}, a pattern commonly applied to solve a composition. Intuitively, we need to come up with a gadget that satisfies all instances but one. Therefore, we require that at least one of the packed instances has a solution.

We begin with showing interreducability of the following problems:

\begin{lemma}
	\ssfep{} parameterized by the number of forced edges and \cnfsat{} parameterized by the number of variables are interreducible.
\end{lemma}

\begin{proof}
	The reductions shown in Lemma \ref{ssfep reduction} and Lemma \ref{cnfsat reduction} are the proof for interreducibility. In both cases, the number of variables or forced edges does not grow.
\end{proof}

Additionally, 

\begin{theorem}
	There exists a cross-composition from \ssfep{} into itself, parameterized by the number of forced edges. Therefore, \ssfep{} parameterized by $|F|$ does not admit a polynomial size kernel unless \textup{NP $\subseteq$ coNP/poly}.
\end{theorem}

\begin{proof}
	Let $\mathcal{R}$ be a polynomial equivalence relation such that two instances, $(G_1,F_1),(G_2, F_2)$, are in the same class if and only if $|F_1| = |F_2|$. Additionally, $\mathcal{R}$ considers equivalently all the malformed graphs. Hence, we assume that all the input instances has the same number of forced edges. It is a natural choice that simplifies further investigations.
	
	Now, we proceed to the construction process. Let $(G_1,F_1),...,(G_t,F_t)$ be the family of $t$ input instances of \ssfep{}. For the sake of clarity, we duplicate some instances so that $t = 2^i$ for some integer $i$. Note that pessimistically, we double the input only.
	
	We are now ready to formally define the output graph and a parameter. Firstly, we create a pair $(G,F)$ by merging forced edges of every input instance. Observe, that we reduced the size of the parameter and now it fits the limit stated in Definition \ref{cross-composition}. Furthermore, we create an instance selector that encodes the OR behavior. We introduce $log(t)$ forced edges $(l_1,r_1),...,(l_{log(t)},r_{log(t)})$. Then, we proceed recursively to add edges. We start with a set $S=\{\{G_1,...,G_t\}\}$. At step $k$, we iterate over every set of $S$ and do the following: split the chosen set in the "middle", take the "left" subset and introduce edges from $l_k$ to every free vertex included in the subset, take the "right" subset and introduce edges from $r_k$ to every free vertex included in the subset, add splitted sets to $S$.
	
	Of course, we did not exceed the stated limit for the parameter. After the addition of the instance selector, the output instance consists of $|F_1|+log(t)$ forced edges. Before we proceed to the second condition, observe that the instance selector guarantees that free vertices from any $t-1$ graphs will be spanned by stars that have a center in instance selector . Therefore, all that remains is to check if at least one graph has a spanning star forest. Hence, the backward implication is simple. Suppose that graph $G_i$ has a spanning star forest. We select edges going from instance selectors in such a way that all graphs but $G_i$ are spanned by a star forest. Thus, we can use forced edges from $F$ to provide a spanning star forest for graph $G_i$. For the forward implication, suppose that the output instance has a spanning star forest. Indeed, instance selector covered at most $t-1$ graphs. Thus, there exists at least one index $i$ for which $(G_i,F_i)$ has a spanning star forest.
\end{proof}


\subsection{Lower bound based on SETH}

Previously in this chapter, we were proving various properties of \ssfep{} problem. We showed that the problem is NP-complete, it does not admit a polynomial kernel and we stated reduction rules to simplify instances. In this subsection, we show a simple routine that solves \ssfep{} parameterized by the number of forced edges. Furthermore, we prove that there does not exist a faster algorithm unless SETH fails.

\begin{algorithm}\label{alg2}
	\KwData{normalized instance $(G,F)$}
	\KwResult{\ssf{} of $G$ extending $F$}
	$Centers \leftarrow \{C: |C|=|F| \text{ and } \forall u,v \in C,\ (u,v) \notin F\}$\;
	\For{$C \in Centers$ }{
		\If{$U \subseteq G[C]$}{
			\Return YES-instance\;
		}
	}
	\Return NO-instance\;
	\caption{Extending a spanning star forest from a reduced graph.}
\end{algorithm}

Consider the following Algorithm \ref{alg2}. It simply iterates over all maximal independent sets of forced candidates. If a set spans all the vertices, then it means that the set of forced edges can be extended to a spanning star forest. Otherwise, if none of the sets is capable of it, then the input is a NO-instance. Now, see the following lemma:

\begin{lemma}\label{alg2-correctness}
	Given a normalized instance $(G,F)$ parameterized by $|F|$, the Algorithm \ref{alg2} outputs the answer whether $(G,F)$ has a spanning star forest.
\end{lemma}

\begin{proof}
	??
\end{proof}

With the Lemma \ref{alg2-correctness}, we can now prove the first main result of the subsection.

\begin{proof}[Proof (of Theorem \ref{thm-ssfep-fe-time})]
	Firstly we normalize the instance by Lemma \ref{norm-ssfe} which takes a polynomial time. Then, Algorithm \ref{alg2} does at most $2^{|F|}$ iterations because this is the number of maximal independent sets in an induced matching. Every iteration takes linear time to process the set. Hence, we conclude that the algorithm works in time $\mathcal{O}^*(2^{|F|})$.
\end{proof}

Note that the described algorithm is a simple brute force. We do not optimize the search. Moreover, there is no need to fight for a better complexity unless SETH fails. The following theorem proves the point.

\begin{proof}[Proof (of Theorem \ref{thm-ssfep-seth})]
	Recall, that we have already presented a sufficient reduction in Lemma \ref{ssfep reduction}. Hence, we want to verify that the existence of an algorithm, running in time stated in the theorem, would contradict SETH. Therefore, suppose that \ssfep{} can be solved in time $\mathcal{O}^*(2^{\delta n})$, for some $\delta < 1$. Assuming SETH, there exists a constant $q \geq 3$ such that $q${\sc -SAT} cannot be solved in time $\mathcal{O}^*(2^{\delta n})$, where $n$ is the number of variables. Consider now the following algorithm for $q${\sc -SAT}: apply the polynomial reduction from Lemma \ref{ssfep reduction} and then solve the resulting instance of \ssfep{} using the assumed faster algorithm. Based on Lemma \ref{cnfsat reduction} we can transform an arbitrary instance of \cnfsat{} of $n$ variables into a \ssfep{} instance with $n$ forced edges. Thus, we could solve $q${\sc -SAT} in time that contradicts SETH.
\end{proof}

\section{Parametrization by the number of non-isolated edges}

\section{Parametrization by treewidth}

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{example}

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
